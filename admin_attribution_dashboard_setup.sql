-- Admin attribution dashboard schema bootstrap
-- Safe to re-run (idempotent where possible)

-- 1) Core analytics tables used by the landing site tracker
CREATE TABLE IF NOT EXISTS public.visits (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  session_id text NOT NULL,
  page_path text NOT NULL,
  referrer text,
  user_agent text,
  country text,
  city text,
  device_type text,
  browser text,
  os text,
  creator_slug text,
  creator_first_touch text,
  creator_last_touch text,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

CREATE TABLE IF NOT EXISTS public.app_clicks (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  event_name text NOT NULL,
  platform text CHECK (platform IN ('ios', 'android')),
  creator_slug text,
  creator_first_touch text,
  creator_last_touch text,
  metadata jsonb,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Ensure legacy existing tables receive required columns too.
ALTER TABLE public.visits
  ADD COLUMN IF NOT EXISTS session_id text,
  ADD COLUMN IF NOT EXISTS page_path text,
  ADD COLUMN IF NOT EXISTS referrer text,
  ADD COLUMN IF NOT EXISTS user_agent text,
  ADD COLUMN IF NOT EXISTS country text,
  ADD COLUMN IF NOT EXISTS city text,
  ADD COLUMN IF NOT EXISTS device_type text,
  ADD COLUMN IF NOT EXISTS browser text,
  ADD COLUMN IF NOT EXISTS os text,
  ADD COLUMN IF NOT EXISTS creator_slug text,
  ADD COLUMN IF NOT EXISTS creator_first_touch text,
  ADD COLUMN IF NOT EXISTS creator_last_touch text,
  ADD COLUMN IF NOT EXISTS created_at timestamp with time zone DEFAULT timezone('utc'::text, now());

ALTER TABLE public.app_clicks
  ADD COLUMN IF NOT EXISTS event_name text,
  ADD COLUMN IF NOT EXISTS platform text,
  ADD COLUMN IF NOT EXISTS creator_slug text,
  ADD COLUMN IF NOT EXISTS creator_first_touch text,
  ADD COLUMN IF NOT EXISTS creator_last_touch text,
  ADD COLUMN IF NOT EXISTS metadata jsonb,
  ADD COLUMN IF NOT EXISTS created_at timestamp with time zone DEFAULT timezone('utc'::text, now());

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM pg_constraint
    WHERE conname = 'app_clicks_platform_check'
      AND conrelid = 'public.app_clicks'::regclass
  ) THEN
    ALTER TABLE public.app_clicks
      ADD CONSTRAINT app_clicks_platform_check CHECK (platform IN ('ios', 'android'));
  END IF;
END;
$$;

-- 2) Creator link source-of-truth
CREATE TABLE IF NOT EXISTS public.creators (
  slug text PRIMARY KEY CHECK (slug ~ '^[a-z0-9][a-z0-9_-]{0,63}$'),
  display_name text NOT NULL,
  ios_url text,
  android_url text,
  is_active boolean NOT NULL DEFAULT true,
  notes text,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  CONSTRAINT creators_at_least_one_url CHECK (ios_url IS NOT NULL OR android_url IS NOT NULL),
  CONSTRAINT creators_ios_https CHECK (ios_url IS NULL OR ios_url ~ '^https://'),
  CONSTRAINT creators_android_https CHECK (android_url IS NULL OR android_url ~ '^https://')
);

-- 3) Admin allowlist table keyed to auth.users
CREATE TABLE IF NOT EXISTS public.admin_users (
  user_id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  email text,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Keep creator updated_at current
CREATE OR REPLACE FUNCTION public.set_creators_updated_at()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
  NEW.updated_at = timezone('utc'::text, now());
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trg_creators_updated_at ON public.creators;
CREATE TRIGGER trg_creators_updated_at
BEFORE UPDATE ON public.creators
FOR EACH ROW
EXECUTE FUNCTION public.set_creators_updated_at();

-- 4) Indexes for reporting/query performance
CREATE INDEX IF NOT EXISTS idx_visits_creator_slug_created_at
  ON public.visits (creator_slug, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_visits_creator_first_touch
  ON public.visits (creator_first_touch);
CREATE INDEX IF NOT EXISTS idx_visits_created_at
  ON public.visits (created_at DESC);

CREATE INDEX IF NOT EXISTS idx_app_clicks_creator_slug_created_at
  ON public.app_clicks (creator_slug, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_app_clicks_creator_first_touch
  ON public.app_clicks (creator_first_touch);
CREATE INDEX IF NOT EXISTS idx_app_clicks_event_name
  ON public.app_clicks (event_name);
CREATE INDEX IF NOT EXISTS idx_app_clicks_created_at
  ON public.app_clicks (created_at DESC);
CREATE INDEX IF NOT EXISTS idx_app_clicks_platform
  ON public.app_clicks (platform);

CREATE INDEX IF NOT EXISTS idx_creators_is_active
  ON public.creators (is_active);

-- 5) Attribution analytics view + admin-only reporting function
--    - clicks include only conversion-intent events
--    - ctr_percent is session-based (click_sessions / open_sessions)
CREATE OR REPLACE VIEW public.creator_attribution_daily_funnel AS
WITH visit_metrics AS (
  SELECT
    DATE(v.created_at) AS date,
    COALESCE(
      NULLIF(v.creator_slug, ''),
      NULLIF(v.creator_last_touch, ''),
      NULLIF(v.creator_first_touch, ''),
      'unattributed'
    ) AS creator_slug,
    COUNT(*) AS opens,
    COUNT(DISTINCT v.session_id) AS open_sessions
  FROM public.visits v
  GROUP BY
    DATE(v.created_at),
    COALESCE(
      NULLIF(v.creator_slug, ''),
      NULLIF(v.creator_last_touch, ''),
      NULLIF(v.creator_first_touch, ''),
      'unattributed'
    )
),
click_metrics AS (
  SELECT
    DATE(c.created_at) AS date,
    COALESCE(
      NULLIF(c.creator_slug, ''),
      NULLIF(c.creator_last_touch, ''),
      NULLIF(c.creator_first_touch, ''),
      NULLIF(c.metadata->>'creator_slug', ''),
      NULLIF(c.metadata->>'creator_last_touch', ''),
      NULLIF(c.metadata->>'creator_first_touch', ''),
      'unattributed'
    ) AS creator_slug,
    COUNT(*) AS clicks,
    COUNT(DISTINCT NULLIF(c.metadata->>'session_id', '')) AS click_sessions
  FROM public.app_clicks c
  WHERE (
    c.event_name ~ '(_ios_clicked|_android_clicked)$'
    OR c.event_name = 'manual_download_clicked'
  )
  GROUP BY
    DATE(c.created_at),
    COALESCE(
      NULLIF(c.creator_slug, ''),
      NULLIF(c.creator_last_touch, ''),
      NULLIF(c.creator_first_touch, ''),
      NULLIF(c.metadata->>'creator_slug', ''),
      NULLIF(c.metadata->>'creator_last_touch', ''),
      NULLIF(c.metadata->>'creator_first_touch', ''),
      'unattributed'
    )
)
SELECT
  COALESCE(v.date, c.date) AS date,
  COALESCE(v.creator_slug, c.creator_slug) AS creator_slug,
  COALESCE(v.opens, 0) AS opens,
  COALESCE(v.open_sessions, 0) AS open_sessions,
  COALESCE(c.clicks, 0) AS clicks,
  COALESCE(c.click_sessions, 0) AS click_sessions,
  CASE
    WHEN COALESCE(v.open_sessions, 0) = 0 THEN 0
    ELSE ROUND((COALESCE(c.click_sessions, 0)::numeric / v.open_sessions::numeric) * 100, 2)
  END AS ctr_percent
FROM visit_metrics v
FULL OUTER JOIN click_metrics c
  ON v.date = c.date
 AND v.creator_slug = c.creator_slug
ORDER BY date DESC, creator_slug ASC;

DROP FUNCTION IF EXISTS public.get_creator_attribution_funnel(date, date);
CREATE OR REPLACE FUNCTION public.get_creator_attribution_funnel(
  start_date date DEFAULT CURRENT_DATE - 30,
  end_date date DEFAULT CURRENT_DATE,
  creator_slug_filter text DEFAULT NULL
)
RETURNS TABLE (
  date date,
  creator_slug text,
  opens bigint,
  open_sessions bigint,
  clicks bigint,
  click_sessions bigint,
  ctr_percent numeric
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  -- Access control is enforced in the Next.js admin API before invoking this RPC.

  RETURN QUERY
  WITH visit_metrics AS (
    SELECT
      DATE(v.created_at) AS metric_date,
      COALESCE(
        NULLIF(v.creator_slug, ''),
        NULLIF(v.creator_last_touch, ''),
        NULLIF(v.creator_first_touch, ''),
        'unattributed'
      ) AS metric_creator_slug,
      COUNT(*) AS opens_count,
      COUNT(DISTINCT v.session_id) AS open_sessions_count
    FROM public.visits v
    WHERE v.created_at >= start_date::timestamptz
      AND v.created_at < (end_date + 1)::timestamptz
    GROUP BY
      DATE(v.created_at),
      COALESCE(
        NULLIF(v.creator_slug, ''),
        NULLIF(v.creator_last_touch, ''),
        NULLIF(v.creator_first_touch, ''),
        'unattributed'
      )
  ),
  click_metrics AS (
    SELECT
      DATE(c.created_at) AS metric_date,
      COALESCE(
        NULLIF(c.creator_slug, ''),
        NULLIF(c.creator_last_touch, ''),
        NULLIF(c.creator_first_touch, ''),
        NULLIF(c.metadata->>'creator_slug', ''),
        NULLIF(c.metadata->>'creator_last_touch', ''),
        NULLIF(c.metadata->>'creator_first_touch', ''),
        'unattributed'
      ) AS metric_creator_slug,
      COUNT(*) AS clicks_count
    FROM public.app_clicks c
    WHERE c.created_at >= start_date::timestamptz
      AND c.created_at < (end_date + 1)::timestamptz
      AND (
        c.event_name ~ '(_ios_clicked|_android_clicked)$'
        OR c.event_name = 'manual_download_clicked'
      )
    GROUP BY
      DATE(c.created_at),
      COALESCE(
        NULLIF(c.creator_slug, ''),
        NULLIF(c.creator_last_touch, ''),
        NULLIF(c.creator_first_touch, ''),
        NULLIF(c.metadata->>'creator_slug', ''),
        NULLIF(c.metadata->>'creator_last_touch', ''),
        NULLIF(c.metadata->>'creator_first_touch', ''),
        'unattributed'
      )
  ),
  visit_sessions AS (
    SELECT
      DATE(v.created_at) AS metric_date,
      COALESCE(
        NULLIF(v.creator_slug, ''),
        NULLIF(v.creator_last_touch, ''),
        NULLIF(v.creator_first_touch, ''),
        'unattributed'
      ) AS metric_creator_slug,
      NULLIF(v.session_id, '') AS session_id
    FROM public.visits v
    WHERE v.created_at >= start_date::timestamptz
      AND v.created_at < (end_date + 1)::timestamptz
      AND NULLIF(v.session_id, '') IS NOT NULL
    GROUP BY
      DATE(v.created_at),
      COALESCE(
        NULLIF(v.creator_slug, ''),
        NULLIF(v.creator_last_touch, ''),
        NULLIF(v.creator_first_touch, ''),
        'unattributed'
      ),
      NULLIF(v.session_id, '')
  ),
  click_sessions AS (
    SELECT
      DATE(c.created_at) AS metric_date,
      COALESCE(
        NULLIF(c.creator_slug, ''),
        NULLIF(c.creator_last_touch, ''),
        NULLIF(c.creator_first_touch, ''),
        NULLIF(c.metadata->>'creator_slug', ''),
        NULLIF(c.metadata->>'creator_last_touch', ''),
        NULLIF(c.metadata->>'creator_first_touch', ''),
        'unattributed'
      ) AS metric_creator_slug,
      NULLIF(c.metadata->>'session_id', '') AS session_id
    FROM public.app_clicks c
    WHERE c.created_at >= start_date::timestamptz
      AND c.created_at < (end_date + 1)::timestamptz
      AND (
        c.event_name ~ '(_ios_clicked|_android_clicked)$'
        OR c.event_name = 'manual_download_clicked'
      )
      AND NULLIF(c.metadata->>'session_id', '') IS NOT NULL
    GROUP BY
      DATE(c.created_at),
      COALESCE(
        NULLIF(c.creator_slug, ''),
        NULLIF(c.creator_last_touch, ''),
        NULLIF(c.creator_first_touch, ''),
        NULLIF(c.metadata->>'creator_slug', ''),
        NULLIF(c.metadata->>'creator_last_touch', ''),
        NULLIF(c.metadata->>'creator_first_touch', ''),
        'unattributed'
      ),
      NULLIF(c.metadata->>'session_id', '')
  ),
  converted_session_metrics AS (
    SELECT
      vs.metric_date,
      vs.metric_creator_slug,
      COUNT(DISTINCT vs.session_id) AS converted_sessions_count
    FROM visit_sessions vs
    INNER JOIN click_sessions cs
      ON cs.metric_date = vs.metric_date
     AND cs.metric_creator_slug = vs.metric_creator_slug
     AND cs.session_id = vs.session_id
    GROUP BY
      vs.metric_date,
      vs.metric_creator_slug
  )
  SELECT
    COALESCE(v.metric_date, c.metric_date) AS date,
    COALESCE(v.metric_creator_slug, c.metric_creator_slug) AS creator_slug,
    COALESCE(v.opens_count, 0) AS opens,
    COALESCE(v.open_sessions_count, 0) AS open_sessions,
    COALESCE(c.clicks_count, 0) AS clicks,
    COALESCE(cm.converted_sessions_count, 0) AS click_sessions,
    CASE
      WHEN COALESCE(v.open_sessions_count, 0) = 0 THEN 0
      ELSE ROUND((COALESCE(cm.converted_sessions_count, 0)::numeric / v.open_sessions_count::numeric) * 100, 2)
    END AS ctr_percent
  FROM visit_metrics v
  FULL OUTER JOIN click_metrics c
    ON v.metric_date = c.metric_date
   AND v.metric_creator_slug = c.metric_creator_slug
  LEFT JOIN converted_session_metrics cm
    ON cm.metric_date = COALESCE(v.metric_date, c.metric_date)
   AND cm.metric_creator_slug = COALESCE(v.metric_creator_slug, c.metric_creator_slug)
  WHERE creator_slug_filter IS NULL
    OR COALESCE(v.metric_creator_slug, c.metric_creator_slug) = creator_slug_filter
  ORDER BY date DESC, creator_slug ASC;
END;
$$;

-- 6) RLS and policies
ALTER TABLE public.visits ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.app_clicks ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.creators ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.admin_users ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Allow public inserts for visits" ON public.visits;
CREATE POLICY "Allow public inserts for visits" ON public.visits
  FOR INSERT TO anon, authenticated
  WITH CHECK (true);

DROP POLICY IF EXISTS "Allow public inserts for app_clicks" ON public.app_clicks;
CREATE POLICY "Allow public inserts for app_clicks" ON public.app_clicks
  FOR INSERT TO anon, authenticated
  WITH CHECK (true);

DROP POLICY IF EXISTS "Allow public reads for active creators" ON public.creators;
CREATE POLICY "Allow public reads for active creators" ON public.creators
  FOR SELECT TO anon, authenticated
  USING (is_active = true);

DROP POLICY IF EXISTS "Allow admin full access to creators" ON public.creators;
CREATE POLICY "Allow admin full access to creators" ON public.creators
  FOR ALL TO authenticated
  USING (EXISTS (
    SELECT 1
    FROM public.admin_users au
    WHERE au.user_id = auth.uid()
  ))
  WITH CHECK (EXISTS (
    SELECT 1
    FROM public.admin_users au
    WHERE au.user_id = auth.uid()
  ));

DROP POLICY IF EXISTS "Allow self-read for admin_users" ON public.admin_users;
CREATE POLICY "Allow self-read for admin_users" ON public.admin_users
  FOR SELECT TO authenticated
  USING (auth.uid() = user_id);

-- 7) Grants (deny by default, then grant minimum)
REVOKE ALL ON public.visits FROM anon, authenticated;
REVOKE ALL ON public.app_clicks FROM anon, authenticated;
REVOKE ALL ON public.creators FROM anon, authenticated;
REVOKE ALL ON public.admin_users FROM anon, authenticated;
REVOKE ALL ON public.creator_attribution_daily_funnel FROM anon, authenticated;

GRANT INSERT ON public.visits TO anon, authenticated;
GRANT INSERT ON public.app_clicks TO anon, authenticated;

GRANT SELECT ON public.creators TO anon, authenticated;
GRANT INSERT, UPDATE, DELETE ON public.creators TO authenticated;

GRANT SELECT ON public.admin_users TO authenticated;

GRANT SELECT ON public.creator_attribution_daily_funnel TO authenticated;
REVOKE EXECUTE ON FUNCTION public.get_creator_attribution_funnel(date, date, text) FROM anon, authenticated;
GRANT EXECUTE ON FUNCTION public.get_creator_attribution_funnel(date, date, text) TO service_role;

DO $$
BEGIN
  IF to_regclass('public.visits_id_seq') IS NOT NULL THEN
    GRANT USAGE, SELECT ON SEQUENCE public.visits_id_seq TO anon, authenticated;
  END IF;

  IF to_regclass('public.app_clicks_id_seq') IS NOT NULL THEN
    GRANT USAGE, SELECT ON SEQUENCE public.app_clicks_id_seq TO anon, authenticated;
  END IF;
END;
$$;

-- 8) Seed existing code-defined creator
INSERT INTO public.creators (slug, display_name, ios_url, android_url, is_active, notes)
VALUES (
  'dobbin',
  'Dobbin',
  'https://gotall.sng.link/D1s0b/svcb?_smtype=3',
  'https://gotall.sng.link/D1s0b/svcb?_smtype=3',
  true,
  'Migrated from src/lib/creatorLinkOverrides.ts'
)
ON CONFLICT (slug) DO UPDATE
SET
  display_name = EXCLUDED.display_name,
  ios_url = EXCLUDED.ios_url,
  android_url = EXCLUDED.android_url,
  is_active = EXCLUDED.is_active,
  notes = EXCLUDED.notes;
